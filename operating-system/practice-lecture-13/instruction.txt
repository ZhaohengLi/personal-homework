第四种实现方式是有误的。
它能满足“忙则等待”，但是不能满足“空闲则入”。
满足“忙则等待”：因为总是有一个进程后修改turn，那么先修改的turn的进程就能够进入。
不满足“空闲则入”：当i进入临界区然后退出，退出时将turn修改为了j，此时 i 就必须等待 j 也执行完毕同样的操作以后才能够继续进入临界区，如果此时 j 恰好不在临界区内，临界区中没有进程的情况下i依旧不能够进入临界区，不满足空闲则入的条件。

第六种实现方式是有误的。
不能满足“空闲则入”。
如果一个进程先执行了flags[i]=BUSY，然后立刻切换到另一个进程执行flags[i]=BUSY。那么此时两个进程的flags均为BUSY，两个进程必定卡死在while循环中，不能满足“空闲则入”。